const mongoose = require('mongoose');
require('dotenv').config();

const { VulnerabilityType } = require('../src/models/catalog/vulnerability-type.model');
const { VulnerabilitySubtype } = require('../src/models/catalog/vulnerability-subtype.model');

const db = process.env.EASYINJECTION_DB;

async function populateSubtypes() {
    try {
        // Conectar a la base de datos
        await mongoose.connect(db);
        console.log('Conectado a la base de datos');

        // Buscar los tipos de vulnerabilidades XSS y SQLi
        const xssType = await VulnerabilityType.Model.findOne({ nombre: 'XSS' });
        const sqliType = await VulnerabilityType.Model.findOne({ nombre: 'SQLi' });

        if (!xssType || !sqliType) {
            console.error('No se encontraron los tipos de vulnerabilidad XSS o SQLi');
            console.log('Por favor ejecuta primero el script de inicialización de tipos');
            process.exit(1);
        }

        console.log('Tipos encontrados:');
        console.log('- XSS:', xssType._id);
        console.log('- SQLi:', sqliType._id);

        // Definir subtipos de XSS
        const xssSubtypes = [
            {
                tipo_id: xssType._id,
                nombre: 'Inyección en contenido HTML',
                descripcion: 'Vulnerabilidad XSS donde el payload se inyecta directamente en el contenido HTML de la página'
            },
            {
                tipo_id: xssType._id,
                nombre: 'Inyección en contenido JavaScript',
                descripcion: 'Vulnerabilidad XSS donde el payload se inyecta dentro de un contexto JavaScript'
            },
            {
                tipo_id: xssType._id,
                nombre: 'Inyección en atributo HTML',
                descripcion: 'Vulnerabilidad XSS donde el payload se inyecta en un atributo HTML (como onclick, href, etc.)'
            },
            {
                tipo_id: xssType._id,
                nombre: 'Cross-Site Scripting',
                descripcion: 'Vulnerabilidad XSS genérica sin contexto específico identificado'
            }
        ];

        // Definir subtipos de SQLi
        const sqliSubtypes = [
            {
                tipo_id: sqliType._id,
                nombre: 'Inyección ciega basada en booleanos (Boolean-based blind)',
                descripcion: 'SQL Injection ciega donde el atacante infiere información basándose en respuestas booleanas (verdadero/falso)'
            },
            {
                tipo_id: sqliType._id,
                nombre: 'Basada en errores (Error-based)',
                descripcion: 'SQL Injection donde el atacante extrae información de los mensajes de error de la base de datos'
            },
            {
                tipo_id: sqliType._id,
                nombre: 'Basada en consultas UNION (Union query-based)',
                descripcion: 'SQL Injection que utiliza el operador UNION para combinar resultados de múltiples consultas'
            },
            {
                tipo_id: sqliType._id,
                nombre: 'Consultas apiladas (Stacked queries)',
                descripcion: 'SQL Injection que permite ejecutar múltiples consultas separadas por punto y coma'
            },
            {
                tipo_id: sqliType._id,
                nombre: 'Inyección ciega basada en tiempo (Time-based blind)',
                descripcion: 'SQL Injection ciega donde el atacante infiere información basándose en retrasos en las respuestas'
            },
            {
                tipo_id: sqliType._id,
                nombre: 'Consultas en línea (Inline queries)',
                descripcion: 'SQL Injection que utiliza subconsultas inline para extraer información'
            }
        ];

        // Insertar subtipos (usar bulkWrite con upsert para evitar duplicados)
        console.log('\nInsertando subtipos de XSS...');
        for (const subtype of xssSubtypes) {
            try {
                await VulnerabilitySubtype.Model.findOneAndUpdate(
                    { tipo_id: subtype.tipo_id, nombre: subtype.nombre },
                    subtype,
                    { upsert: true, new: true }
                );
                console.log(`✓ ${subtype.nombre}`);
            } catch (err) {
                console.error(`✗ Error insertando ${subtype.nombre}:`, err.message);
            }
        }

        console.log('\nInsertando subtipos de SQLi...');
        for (const subtype of sqliSubtypes) {
            try {
                await VulnerabilitySubtype.Model.findOneAndUpdate(
                    { tipo_id: subtype.tipo_id, nombre: subtype.nombre },
                    subtype,
                    { upsert: true, new: true }
                );
                console.log(`✓ ${subtype.nombre}`);
            } catch (err) {
                console.error(`✗ Error insertando ${subtype.nombre}:`, err.message);
            }
        }

        // Mostrar resumen
        const totalXss = await VulnerabilitySubtype.Model.countDocuments({ tipo_id: xssType._id });
        const totalSqli = await VulnerabilitySubtype.Model.countDocuments({ tipo_id: sqliType._id });

        console.log('\n=== RESUMEN ===');
        console.log(`Subtipos XSS en BD: ${totalXss}`);
        console.log(`Subtipos SQLi en BD: ${totalSqli}`);
        console.log('\n✓ Script completado exitosamente');

        process.exit(0);
    } catch (error) {
        console.error('Error ejecutando el script:', error);
        process.exit(1);
    }
}

// Ejecutar el script
populateSubtypes();
